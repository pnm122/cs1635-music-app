These are just notes to myself for future reference to explain why I made the design choices I did. Feel free to read them tho :)

### Change to make post lists reusable

In its previous implementation, a PostView took in a boolean to say whether the list was the user's following feed or all popular posts, making it unusable anywhere else in code. I needed it to be used on profile pages to display all of the users' posts and on song pages, to display all of the covers of a song. The clear way to do this was to pass in a List of Post into the PostViewModel, so that PostViews could be used anywhere with any Posts. I then wrapped the homepage in a viewmodel so that we could get the popular and following posts that we will pass into the PostViews. The problem then was that the following post list wouldn't update, because followingPosts was just a static list in the HomepageViewModel. I wanted to call a function inside of HomepageViewModel to refresh followingPosts, but not all PostViews will have a HomepageViewModel above it to reference. To solve this, I pass in an optional parameter into PostViews where you can declare if the PostView is part of the homepage. If so, when you follow/unfollow a user, it also calls the updateFollowingPosts function in HomepageViewModel. The current behavior is that when a user is unfollowed on the following tab, the posts don't get removed immediately from the following tab, but only when you leave that tab and come back to it. This is the behavior I want, because it means the following page won't jump the instant you unfollow someone. This happens because the PostView isn't watching the HomePageViewModel's following posts.

### How the different search pages work

The search route takes in 2 arguments, with a potential 3rd. The first argument is a list of search types that tells the search view model which type of results the search page should show (under separate tabs for each). The search view reads the viewmodel's search types and decides how to layout the page based on those. The 2nd argument is the search behavior, which decides what "behavior" the search page has. For example, "followersBehavior" causes the viewmodel to limit search results to followers of the current user (and also silently requires the first argument to be [ userSearch ]). For settingFavoriteBehavior and attachingSongBehavior, a 3rd argument must be passed in: the viewmodel of the page calling Navigator.pushNamed(). This is because these behaviors cause tapping on a search result to call a function that's in this viewmodel. I have short explanations for each behavior written inside search_constants.dart.