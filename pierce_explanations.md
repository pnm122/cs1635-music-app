These are just notes to myself for future reference to explain why I made the design choices I did. Feel free to read them tho :)

### Change to make post lists reusable

In its previous implementation, a PostView took in a boolean to say whether the list was the user's following feed or all popular posts, making it unusable anywhere else in code. I needed it to be used on profile pages to display all of the users' posts and on song pages, to display all of the covers of a song. The clear way to do this was to pass in a List of Post into the PostViewModel, so that PostViews could be used anywhere with any Posts. I then wrapped the homepage in a viewmodel so that we could get the popular and following posts that we will pass into the PostViews. The problem then was that the following post list wouldn't update, because followingPosts was just a static list in the HomepageViewModel. I wanted to call a function inside of HomepageViewModel to refresh followingPosts, but not all PostViews will have a HomepageViewModel above it to reference. To solve this, I pass in an optional parameter into PostViews where you can declare if the PostView is part of the homepage. If so, when you follow/unfollow a user, it also calls the updateFollowingPosts function in HomepageViewModel. The current behavior is that when a user is unfollowed on the following tab, the posts don't get removed immediately from the following tab, but only when you leave that tab and come back to it. This is the behavior I want, because it means the following page won't jump the instant you unfollow someone. This happens because the PostView isn't watching the HomePageViewModel's following posts.

### How the different search pages work

The search route takes in 2 arguments, with a potential 3rd. The first argument is a list of search types that tells the search view model which type of results the search page should show (under separate tabs for each). The search view reads the viewmodel's search types and decides how to layout the page based on those. The 2nd argument is the search behavior, which decides what "behavior" the search page has. For example, "followersBehavior" causes the viewmodel to limit search results to followers of the current user (and also silently requires the first argument to be [ userSearch ]). The 3rd argument is an additional parameter needed for some behaviors. For settingFavoriteBehavior and attachingSongBehavior, it is the viewmodel of the page calling Navigator.pushNamed(). This is because these behaviors cause tapping on a search result to call a function that's in this viewmodel. For followersBehavior and followingBehavior, this is the user that we want the followers/following of, which is passed into the viewmodel and used for the list of items I want to display. I have short explanations for each behavior written inside search_constants.dart.

### How the comment number updates properly
Comments pages have to access the PostViewModels to notify PostViews when a new comment is created. To do this, all post views need the associated viewmodel to be passed in so that the comments page can use ChangeNotifierProvider.value on it and access the same PostViewModel instance. updateComments within the PostViewModel just calls notifyListeners() since I already updated the comments and therefore the # of comments, so the UI just needs to know to refresh. The only issue doing this is that, when there are tabs and I place the PostViewModel variable in the build function of the widget that contains the tabs, this viewmodel will get destroyed when switching tabs and cause an error when you switch back because it tries to use the same destroyed viewmodel. To solve this problem, I created a new widget to use inside TabBarView, with the viewmodel variable inside of that. This way, my understanding is that this viewmodel gets created every time that you switch to that tab, so the error no longer happens.